"""Playground module for practicing adding type hints to
Python code.

You may assume that the functions in this module operate on
strings. Your type hints should be as generic as possible.

Disclaimer: This module was generated by https://claude.ai/.
"""
from typing import List, TypeVar, Union, Any, Protocol

def reverse_string(s: str) -> str:
    """
    Returns the string in the reverse order

    Parameters:
    (s: str) : The string to reverse
    str : the reversed string.
    """
    return s[::-1]





def count_vowels(s: str) -> int:

    """
    Counts the the number of vowels in the given string.

    Parameters:
    (s: str) : The string to count vowels.
    int : the number of vowels in the given string.

    """

    vowels = 'aeiouAEIOU'
    return sum(1 for char in s if char in vowels)




def is_palindrome(s: str) -> bool:

    """
    Checks if the given string is a palindrome.

    Parameters:
    (s: str) : The string to check.
    bool : true if the given string is a palindrome, otherwise false.
    """

    s = ''.join(char.lower() for char in s if char.isalnum())
    return s == s[::-1]



def find_longest_word(sentence: str) -> str:

    """
    Find the longest word in the given sentence.

    Parameters:
    (sentence: str) : The given sentence.
    str : the longest word in the sentence, or an empty string if no words.

    """

    words = sentence.split()
    return max(words, key=len) if words else ''




T = TypeVar('T')
def remove_duplicates(lst: List[T]) -> List[T]:

    """
    Removes the dublicate elements form the list.

    Parameters:
    (lst: List[T]) : The list to check.
    List[T] : a new list without dublicates.

    """

    return list(dict.fromkeys(lst))



class Comparable(Protocol):
    """
    Defines a comparison between comparable objects.

    Parameters:
    (__lt__) : less than.
    (__le__) : less than or equal to.


    self : the current object compared.
    other: the object to compare against.
    bool: true if the current object is less than or equal to other object, false otherwise.


    """

    def __lt__(self, other: "Comparable") -> bool: ...
    def __le__(self, other: "Comparable") -> bool: ...



R = TypeVar('R', bound=Comparable)
def merge_sorted_lists(list1: List[R], list2: List[R]) -> List[R]:

    """
    Merges two sorted lists into one sorted list.

    Parameters:
    (list1: List[R]) : first sorted list.
    (list2: List[R]) : second sorted list.

    List[R] : returns a new sorted list containing elements from list1 and list2.
    """

    result = List()
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] <= list2[j]:
            result.append(list1[i])
            i += 1
        else:
            result.append(list2[j])
            j += 1
    result.extend(list1[i:])
    result.extend(list2[j:])
    return result



def flatten_list(nested_list: List[Union[Any, List[Any]]]) -> List[Any]:

    """
    Flattens a nested list into a single list.

    Parameters:

    (nested_list: List) : The nested list to flatten.
    List[Any] : A flattened version of the list.
    """

    flat_list: List[Any]= []
    for item in nested_list:
        if isinstance(item, list):
            flat_list.extend(flatten_list(item))
        else:
            flat_list.append(item)
    return flat_list


def calculate_average(numbers: List[Union[int, float]]) -> float:

    """
    Computes the avarage of the numbers.

    Parameters:
    (numbers: List) : the list of numbers to compute the avarage.
    float: The avarage of the numbers, or 0 if the list is empty.
    """

    return sum(numbers) / len(numbers) if numbers else 0.0



    #T=TypeVar('T')
def find_common_elements(list1: List[T], list2: List [T]) -> List[T]:

    """
    Finds common elements between two lists.

    Parameters:
    list1: List[T] : given first list.
    list2: List[T] : given second list.

    list : a list of elements both common in two lists.
    """

    return list(set(list1) & set(list2))



def rotate_list(lst: List[T], k: int) -> List[T]:
    """
    Rotates a list by 'k' positions.

    Parameters:

    lst: list[T] : the list to rotate.
    k (int) : The number of positions to rotate the list by.

    Returns:
    list: the rotated list.

    SEEALSO:
        :func:`flatten_list` : A function to flatten a nested list.
    """
    if not lst:
        return lst
    k = k % len(lst)
    return lst[-k:] + lst[:-k]
